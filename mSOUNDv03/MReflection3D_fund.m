function [ref_fundamental] = MReflection3D_fund(mgrid, medium, p_ref, ...
                             M_linear, K, omega_c, reflection_order, c_ref, H, MDMI, MDMD)

% DESCRIPTION:
% Computing the 3D wave field of reflection at the frequency of interest. This
% function is used by solver 2 which is applicable to strongly inhomogeneous
% media. An odd number of reflection order indicates one-way propagation in the
% backward direction (-z), while an even number of reflection order indicates
% one-way propagation in the forward direction (+z).

% USAGE:
% [ref_fundamental] = MReflection3D_fund(mgrid, medium, p_ref, ...
%                     M_linear, K, omegac, reflection_order, c_ref, H, MDMI, MDMD)

% INPUTS:
% mgrid              Structure to define the computational domain
% medium             Medium properties
% p_ref              Reflected wave field generated by the main forward wave
%                    propagation code
% M_linear           M term
% K                  z-component of the wave-vector
% omega_c            Center frequency 2*pi*fc 
% reflection_order   The maximum order of reflection included in the simulation
% c_ref              A set of reference sound velocities covering the sound 
%                    velocity distribution of the acoustic medium. 
% H                  Interpolation function used by the split-step Fourier
%                    method
% MDMI               Flag for integration scheme
%                    0: Trapzoidal rule (default)
%                    1: left-point Riemann sum rule 
% MDMD               Flag for data type (0: double; 1: single)

% OUTPUTS:
% ref_fundamental    Wave field of reflection at the frequency of interest


%%
%Filter cutoff for removing singularities at points on the radiation circle
threshold = 10;

% preallocate space for the reflection field
% assigning near-zero complex values to speed up the process of filling complex matrices
if MDMD ==1
ref_fundamental = 1e-16*1i*ones(mgrid.num_x, mgrid.num_y,mgrid.num_z,'single');
else 
ref_fundamental = zeros(mgrid.num_x,mgrid.num_y,mgrid.num_z,'like',1+1i);
end

% exponential terms to be used in the for loop
expn2 = exp(1i*K*mgrid.dz); 
expn3 = mgrid.dz*expn2./(2i.*K);

for iref = 1:reflection_order
    
    if mod(iref,2)==1
        if reflection_order>1
        p_ref2 = zeros(mgrid.num_x,mgrid.num_y,mgrid.num_z,'like',1+1i); 
        end
        f = 0;
     
        label = ['Computing the reflection of order ',num2str(iref),',please wait...'];
        multiWaitbar(label);
  
        for I = mgrid.num_z-1 :-1:1           
            f = f + p_ref(:,:, I+1);    
            if ~any(real(f),'all') %determine whether there is reflected wave
            f=0;
            else
            excit_F = fftshift(fft2(f));
    
            M  = fftshift(fft2(M_linear(:,:,I+1).*f));
            f=0; 
            for II = 1:length(c_ref)
            if MDMI ==1
            F1 = excit_F.*expn2(:,:,II) + expn3(:,:,II).*M;
            F1(isnan(F1)) = 0;
            F1(abs(K(:,:,II))<threshold)=0;
            f1 = ifft2(ifftshift(F1));
        
            elseif MDMI ==0
            F1 = excit_F.*expn2(:,:,II) + expn3(:,:,II).*M;
            F1(isnan(F1)) = 0;
            F1(abs(K(:,:,II))<threshold)=0;
        
            f1  = ifft2(ifftshift(F1));  
            M1 = fftshift(fft2(M_linear(:,:,I).*f1));
            F2 = excit_F.*expn2(:,:,II) + 0.5*expn3(:,:,II).*(M + M1./expn2(:,:,II));
            F2(isnan(F2)) = 0;
            F2(abs(K(:,:,II))<threshold)=0;
            f1 = ifft2(ifftshift(F2));
            end
            
            f1 = f1*exp(1i*omega_c/c_ref(II)*mgrid.dz).*exp(-1i*omega_c./medium.c(:,:,I+1)*mgrid.dz);
            f1 = f1.*H(:,:,I+1,II);
            f = f+f1;
            end  
%% Computing the transmission coefficient (plane wave and layered-medium approximation) 
            T_rhoc = 2* medium.rho(:,:,I).*medium.c(:,:,I)./(medium.rho(:,:,I+1).*medium.c(:,:,I+1) + ...
                medium.rho(:,:,I).*medium.c(:,:,I));
%% add reflection      
            if reflection_order>1&&any(T_rhoc-1,'all')
            p_ref2(:,:, I+1) = f.*(T_rhoc-1);
            end           
            f = f.*T_rhoc;   
            ref_fundamental(:,:, I) = ref_fundamental(:,:,I) + f;  
            end
            multiWaitbar(label,'value',(mgrid.num_z-I)/mgrid.num_z);
   
        end        
        %close(h)
    else
        if reflection_order>2
        p_ref = zeros(mgrid.num_x,mgrid.num_y,mgrid.num_z,'like',1+1i);        
        end
        f = 0;

       label = ['Computing the reflection of order ',num2str(iref),',please wait...'];
       multiWaitbar(label);
       for I = 2:mgrid.num_z
            
        f = f + p_ref2(:,:,I-1); 
        if ~any(real(f),'all')
        f=0;
        else
            
        excit_F = fftshift(fft2(f));
        M  = fftshift(fft2(M_linear(:,:,I-1).*f));
        f=0;
        
        for II = 1:length(c_ref)
        if MDMI ==1
        F1 = excit_F.*expn2(:,:,II) + expn3(:,:,II).*M;
        F1(isnan(F1)) = 0;
        F1(abs(K(:,:,II))<threshold)=0;
        f1 = ifft2(ifftshift(F1));
        
        elseif MDMI ==0
        F1 = excit_F.*expn2(:,:,II) + expn3(:,:,II).*M;
        F1(isnan(F1)) = 0;
        F1(abs(K(:,:,II))<threshold)=0;
        
        f1  = ifft2(ifftshift(F1));  
        
        M1 = fftshift(fft2(M_linear(:,:,I).*f1));
        F2 = excit_F.*expn2(:,:,II) + 0.5*expn3(:,:,II).*(M + M1./expn2(:,:,II));
        F2(isnan(F2)) = 0;
        F2(abs(K(:,:,II))<threshold)=0;
        f1 = ifft2(ifftshift(F2));
        end
            
        f1 = f1*exp(1i*omega_c/c_ref(II)*mgrid.dz).*exp(-1i*omega_c./medium.c(:,:,I-1)*mgrid.dz);
        f1 = f1.*H(:,:,I-1,II);
        f = f+f1;
        end
    
%% Computing the transmission coefficient (plane wave and layered-medium approximation)  
        T_rhoc = 2* medium.rho(:,:,I).*medium.c(:,:,I)./(medium.rho(:,:,I-1).*medium.c(:,:,I-1) + ...
                medium.rho(:,:,I).*medium.c(:,:,I));           
%% add reflection  
            if reflection_order>2&&any(T_rhoc-1,'all')
            p_ref(:,:, I-1) = f.*(T_rhoc-1);
            end

            f = f.*T_rhoc;                 
            ref_fundamental(:,:, I) = ref_fundamental(:,:,I) + f;  
        end
        
       multiWaitbar(label,'value',I/mgrid.num_z);
       end
 
    end
end
end
