function [ref_fundamental] = Reflection3D_fund(mgrid, medium, p_ref, ...
                                       M_linear, K, reflection_order, MDMI, MDMD)

% DESCRIPTION:
% Computing the 3D wave field of reflection at the frequency of interest. This
% function is used by solver 1 which is applicable to weakly inhomogeneous
% media. An odd number of reflection order indicates one-way propagation in the
% backward direction (-z), while an even number of reflection order indicates
% one-way propagation in the forward direction (+z).

% % USAGE:
% [ref_fundamental] = Reflection3D_fund(mgrid, medium, p_ref, ...
%                     M_linear, K, reflection_order, MDMI, MDMD)

% INPUTS:
% mgrid              Structure to define the computational domain
% medium             Medium properties
% p_ref              Reflected wave field generated by the main forward wave
%                    propagation code
% M_linear           M term
% K                  z-component of the wave-vector
% reflection_order   The maximum order of reflection included in the simulation
% MDMI               Flag for integration scheme 
%                    0: Trapzoidal rule (default)
%                    1: left-point Riemann sum rule
% MDMD               Flag for data type (0: double; 1: single)
%
% OUTPUTS:
% ref_fundamental    Wave field of reflection at the frequency of interest
%%
%Filter cutoff for removing singularities at points on the radiation circle
threshold = 10;

% preallocate space for the reflection field
% assigning near-zero complex values to speed up the process of filling complex matrices
if MDMD ==1
ref_fundamental = 1e-16*1i*ones(mgrid.num_x, mgrid.num_y,mgrid.num_z,'single');
else 
ref_fundamental = zeros(mgrid.num_x,mgrid.num_y,mgrid.num_z,'like',1+1i);
end

expn2 = exp(1i*K*mgrid.dz); 
expn3 = mgrid.dz*expn2./(2i.*K);   

for iref = 1:reflection_order
    
    if mod(iref,2)==1
        if reflection_order>1
        p_ref2 = zeros(mgrid.num_x,mgrid.num_y,mgrid.num_z,'like',1+1i); 
        end 
        f = 0;

        label = ['Computing the reflection of order ',num2str(iref),',please wait...'];
        multiWaitbar(label);
        for I = mgrid.num_z-1 :-1:1
            
            f = f + p_ref(:,:, I+1);  
            if ~any(real(f),'all') %determine whether there is reflected wave
            f=0;        
            else
            excit_F = fftshift(fft2(f));
            M  = fftshift(fft2(M_linear(:,:,I+1).*f));

        if MDMI ==1 %left-point Riemann sum scheme
        F1 = excit_F.*expn2 + expn3.*M;
        F1(isnan(F1)) = 0;
        F1(abs(K)<threshold)=0;%removing singularities at points on the radiation circle
        f = ifft2(ifftshift(F1));
        
        elseif MDMI ==0 %trapzoidal rule
        F1 = excit_F.*expn2 + expn3.*M;
        F1(isnan(F1)) = 0;
        F1(abs(K)<threshold)=0;
        
        f1  = ifft2(ifftshift(F1));      
        M1 = fftshift(fft2(M_linear(:,:,I).*f1));
        F2 = excit_F.*expn2 + 0.5*expn3.*(M + M1./expn2);
        F2(isnan(F2)) = 0;
        F2(abs(K)<threshold)=0;
        f = ifft2(ifftshift(F2));        
        end
%% add reflection              
            T_rhoc = 2* medium.rho(:,:,I).*medium.c(:,:,I)./(medium.rho(:,:,I+1).*medium.c(:,:,I+1) + ...
                medium.rho(:,:,I).*medium.c(:,:,I));
            if reflection_order>1&&any(T_rhoc-1,'all')
            p_ref2(:,:, I+1) = f.*(T_rhoc-1);
            end 
            f = f.*T_rhoc;  
            ref_fundamental(:,:, I) = ref_fundamental(:,:,I) + f;
            end
            %waitbar((mgrid.num_z-I)/mgrid.num_z)  
            multiWaitbar(label,'value',(mgrid.num_z-I)/mgrid.num_z);
        end
        %close(h)
    else
        if reflection_order>2
        p_ref = zeros(mgrid.num_x,mgrid.num_y,mgrid.num_z,'like',1+1i);
        end
        f = 0;
        %h = waitbar(0,['Computing the reflection of order ',num2str(iref),', please wait...']);
        label = ['Computing the reflection of order ',num2str(iref),',please wait...'];
        multiWaitbar(label);
        for I = 2:mgrid.num_z     
            f = f + p_ref2(:,:,I-1); 
            if ~any(real(f),'all')
            f=0;
            else
            excit_F = fftshift(fft2(f));                   
        M  = fftshift(fft2(M_linear(:,:,I-1).*f));               
        if MDMI ==1 %left-point Riemann sum scheme
        F1 = excit_F.*expn2 + expn3.*M;
        F1(isnan(F1)) = 0;
        F1(abs(K)<threshold)=0;%removing singularities at points on the radiation circle
        f = ifft2(ifftshift(F1));
        
        elseif MDMI ==0 %trapzoidal rule
        F1 = excit_F.*expn2 + expn3.*M;
        F1(isnan(F1)) = 0;
        F1(abs(K)<threshold)=0;
        
        f1  = ifft2(ifftshift(F1));      
        M1 = fftshift(fft2(M_linear(:,:,I).*f1));
        F2 = excit_F.*expn2 + 0.5*expn3.*(M + M1./expn2);
        F2(isnan(F2)) = 0;
        F2(abs(K)<threshold)=0;
        f = ifft2(ifftshift(F2));        
        end
            %% add reflection 
        T_rhoc = 2* medium.rho(:,:,I).*medium.c(:,:,I)./(medium.rho(:,:,I-1).*medium.c(:,:,I-1) + ...
                medium.rho(:,:,I).*medium.c(:,:,I)); 
            
            if reflection_order>2&&any(T_rhoc-1,'all')
            p_ref(:,:, I-1) = f.*(T_rhoc-1);
            end
            f = f.*T_rhoc; 
            ref_fundamental(:,:, I) = ref_fundamental(:,:,I) + f;  
            end
            %waitbar(I/mgrid.num_z)  
            multiWaitbar(label,'value',I/mgrid.num_z);
        end
        %close(h) 
    end
end
end
